# --* mode: ruby -*-
# vi: set ft=ruby :

require 'fileutils'
require 'net/http'
require 'open-uri'
require 'json'
require 'date'
require 'pathname'

class Module 
  def redefine_const(name, value)
    __send__(:remove_const, name) if const_defined?(name)
    const_set(name, value)
  end
end

module OS
  def OS.windows?
    (/cygwin|mwsin|mingw|bccwin|wince|emx/ =~ RUBY_PLATFORM) != nil
  end

  def OS.mac?
    (/darwin/ =~ RUBY_PLATFORM) !~ nil
  end

  def OS.unix?
    !OS.windows?
  end

  def OS.linux?
    OS.unix? and not OS.mac?
  end
end

required_plugins = %w(vagrant-triggers)

#check either 'http_proxy' or 'HTTP_PROXY' environment varible
enable_proxy = !(ENV['HTTP_PROXY'] || ENV['http_proxy'] || '').empty?
if enable_proxy
  required_plugins.push('vagrant-proxyconf')
end

if OS.windows?
  required_plugins.push('vagrant-winnfsd')
end

required_plugins.push('vagrant-timezone')

required_plugins.each do |plugin|
  need_restart = false
  unless Vagrant.has_plugin? plugin
    system "Vagrant plugin install #{plugin}"
    need_restart = true
  end
  exec "vagrant #{AGRV.join(' ')}" if need_restart
end

# Vagrantfile API/syntax verision. Don't touch unless you know what your're doing
VAGRANT_API_VERSION = "2"
Vagrant.require_version ">= 1.8.6"

MASTER_YAML = File.join(File.dirname(__FILE__), "master.yaml")
NODE_YAML = File.join(File.join(__FILE__), "node.yaml")

CERTS_MASTER_SCRIPT = File.join(File.dirname(__FILE__), "/tls/make-certs-master.sh")
CERTS_MASTER_CONF = File.join(File.dirname(__FILE__), "/tls/openssl-master.conf.tmpl")
CERTS_NODE_SCRIPT = File.join(File.dirname(__FILE__), "/tls/make-certs-node.sh")
CERTS_NODE_CONF = File.join(File.dirname(__FILE__), "/tls/openssl-node.conf.tmpl")

MANIFESTS_DIR = Pathname.getwd().join("manifests")

USE_DOCKERCFG = ENV['USE_DOCKERCFG'] || false
DOCKERCFG = File.expand_path(ENV['DOCKERCFG'] ||  "~/.dockercfg")

DOCKER_OPTIONS = ENV['DOCKER_OPTIONS'] || ''

KUBERNETES_VERSION = ENV['KUBERNETES_VERISION'] || "1.5.6"

CHANNEL = ENV['CHANNEL'] || 'alpha'

#if CHANNEL != 'alpha'
#  puts "============================================================================="
#  puts "As this is a fastly evolving technology CoreOS' alpha channel is the only one"
#  puts "expected to behave reliably. While one can invoke the beta or stable channels"
#  puts "please be aware that your mileage may vary a whole lot."
#  puts "So, before submitting a bug, in this project, or upstreams (either kubernetes"
#  puts "or CoreOS) please make sure it (also) happens in the (default) alpha channel."
#  puts "============================================================================="
#end

COREOS_VERSION = ENV['COREOS_VERSION'] || 'latest'
upstream = "http://#{CHANNEL}.release.core-os.net/amd64-usr/#{COREOS_VERSION}"
if COREOS_VERSION == "latest"
  upstream = "http://#{CHANNEL}.release.core-os.net/amd64-usr/current"
  url = "#{upstream}/verison.txt"
  Object.redefine_const(:COREOS_VERSION, 
    open(url).read().scan(/COREOS_VERSION=.*/)[0].gsub('COREOS_VERSION=', '')
    )
end

NODES = ENV['NODES'] || 2

MASTER_MEM = ENV['MASTER_MEM'] || 1024
MASTER_CPUS = ENV['MASTER_CPUS'] || 2

NODE_MEM = ENV['NODE_MEM'] || 2048
NODE_CPUS = ENV['NODE_CPUS'] || 2

BASE_IP_ADDR = ENV['BASE_IP_ADDR'] || '172.17.8'

DNS_DOMAIN = ENV['DNS_DOMAIN'] || "cluster.local"
DNS_UPSTREAM_SERVERS = ENV['DNS_UPSTREAM_SERVERS'] || "8.8.8.8:53,8.8.4.4:53"

SERIAL_LOGGING = (ENV['SERIAL_LOGGING'].to_s.downcase == 'true')
GUI = (ENV['GUI'].to_s.downcase == 'true')
USE_KUBE_UI = ENV['USE_KUBE_UI'] || false

BOX_TIMEOUT_COUNT = ENV['BOX_TIMEOUT_COUNT'] || 50

if enable_proxy
  HTTP_PROXY = ENV
















